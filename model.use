model Delivery


enum Etat_Box {Free, Occupied, Full}
enum Etat_Command {Waiting,Assigned,Finished}
--_________________________
--CLASSES
--_________________________

class Point
	attributes 
		x : Integer
		y : Integer	
	operations
		-- Computing the distance between two points 
		d(p2 : Point ) : Integer =
			(self.x - p2.x).abs + (self.y - p2.y).abs
		-- Déterminer si à un point, il y a une Box ou une Warehouse
end

class Box < Point
    attributes
        capacity : Integer
        state : Etat_Box init = Etat_Box::Free
    operations 
        voisins() : Set(Box) =
            Box.allInstances() -> select (n | d(n) < 3)
        voisinsPlus() : Set(Box) =
            self.voisins() -> closure (b|b.voisins())
        distance(d : Drone) : Integer =
            (self.x-d.position4drone.x).abs + (self.y-d.position4drone.y).abs
    	setOccupied()
    	begin
    		self.state := Etat_Box::Occupied;
		end
		setFree()
		begin
			self.state := Etat_Box::Free;
		end
		setFull()
		begin
			self.state := Etat_Box::Full;
		end
	statemachines
    psm StateMachineForBox
        states
        	startUp:initial
            free
            full
            occupied
         transitions
         	startUp -> free { create }
            free -> occupied {[Drone.allInstances()->one(d | distance(d) = 0)] setOccupied()}
            occupied -> free {[Drone.allInstances()->forAll(d | distance(d) <> 0)] setFree()}
            free -> full {[self.capacity = 50] setFull()}	--RCAP
            occupied -> full {[self.capacity = 50] setFull()}
            full -> free {[self.capacity = 0 and Drone.allInstances()->forAll(d | distance(d) <> 0)] setFree()}
            full -> occupied {[self.capacity = 0 and Drone.allInstances()->one(d | distance(d) = 0)] setOccupied()}
    end
end

class Drone

	attributes 
		energy : Integer init = 0
		capacity : Integer init = 0
	operations
		
		assign(c : Command)
		begin
			insert(c, self) into delivery;
		end

		fill()
		begin
			for p in self.cmd4drone.product4cmd do
				self.capacity := self.capacity + p.weight
			end
		end

		recharge ()
		begin
			-- TODO : time ++
			self.energy := self.energy +1;
		end

		unloadAndValidate()
		begin
			self.capacity := 0;
			--TODO: Remplir la box la où on est. 
			--Supprimer l'association entre Drone et Command
			delete (self.cmd4drone, self) from delivery;
		end

		move (moveX : Integer, moveY : Integer)
		begin
			self.position4drone.x := self.position4drone.x + moveX;
			self.position4drone.y := self.position4drone.y + moveY;
			self.energy := self.energy -1;
		end

	statemachines
		psm StateMachineOfADrone
			states
				startUp:initial
				commandAssigned
				productsCharged
			transitions
				startUp -> commandAssigned {assign()}
				commandAssigned -> productsCharged {fill()}
		end
end

class Command
	attributes
		state : Etat_Command
	operations
	 	setAssigned()
	 	begin
	 		self.state := Etat_Command::Assigned
	 	end
	 	setFinished()
	 	begin
	 		self.state := Etat_Command::Finished
	 	end
	statemachines
		psm StateMachineForACommand
			states
				startUp:initial
				Waiting
				Assigned
				Finished:final
			transitions
				startUp -> Waiting { create }
				Waiting -> Assigned { [Drone.allInstances()->one(d|d.cmd4drone = self)] setAssigned() }
				Assigned -> Finished { [Drone.allInstances()->one(d|d.cmd4drone = self and d.position4drone.x = self.cmdDestination.x and d.position4drone.y = self.cmdDestination.y and d.capacity = 0)] setFinished() }
		end
end
class Warehouse < Box end
class Product
	attributes
		weight : Integer
end 

class Time end


--_______________________________
--CONTRAINTES
--_______________________________

constraints

--_____________
--Sur les classes
--_____________

context Warehouse inv oneWarehouse : Warehouse.allInstances->size=1


context b1,b2:Box inv noTwoBoxesAtSamePlace : 
	 (b1.x = b2.x) and 
	 (b1.y = b2.y)
	 implies b1 = b2


context d1,d2:Drone inv noTwoDronesAtSamePlace :
	(d1.position4drone.x = d2.position4drone.x) and
	(d1.position4drone.y = d2.position4drone.y)
	implies d1 = d2


context w:Warehouse inv neighbourBoxNearWarehouse :
    Box.allInstances() -> exists (b | d(b) < 3 )

context Drone inv batteryPositive : self.energy >= 0
context Drone inv batteryNotTooHigh : self.energy <= 3 
context Drone inv maxDroneNb : Drone.allInstances -> size <= 15
-- DNB
context Box inv maxBoxNb : Box.allInstances -> size <=20
-- RNB
context Drone inv droneCapacityPositive : self.capacity >= 0
context Drone inv droneCapacityMax : self.capacity <= 20 
-- DCAP
context Box inv boxCapacityPositive : self.capacity >= 0
context Box inv boxCapacityMax : self.capacity <= 50
-- RCAP

--context Point inv numberOfNeighbours : 
--	(self.neighbour-> size >=2) and
--	(self.neighbour-> size <=4)

-- Il faut que les voisins ne soient pas à plus de 1
--context p:Point inv neighboursAreClose :
--	p.neighbour->forAll(n | 
--	(((n.x - p.x = 1) or
--	(n.x - p.x =-1)) and
--	n.y - p.y =0) or
--	(((n.y - p.y = 1) or
--	(n.y - p.y =-1)) and
--	n.x - p.x =0))

-- Voisins doivent être différents !!! Pas besoin mais expliquer dans le dossier

context b1:Box inv transitiveClosureComplete :
	b1.voisinsPlus()->includesAll(Box.allInstances())
--_____________
--Sur les fonctions (post et pré condition)
--_____________
	
context Drone::recharge()
	pre droneIsNotFullyRecharged: self.energy < 3
	pre droneIsAtBox: Box.allInstances->exists (b | b.distance(self) =0)
	post droneIsStillAtBox: Box.allInstances->exists (b | b.distance(self) =0)
	-- post rechargePost2 : tempsAprès = tempsAvant + nbRecharges

context Drone::fill()
	pre droneIsInTheWh: Warehouse.allInstances->exists(w | w.distance(self) =0)
	pre droneIsEmpty: self.capacity = 0
	--On considère qu'une commande correspond à un seul aller-retour

context Drone::assign(c:Command)	
	--On considère qu'une commande correspond à un seul aller-retour
	pre droneIsInTheWh: Warehouse.allInstances->exists(w | w.distance(self) =0)
	pre noCommandYet: not Command.allInstances-> exists(c | self.cmd4drone = c) 

context Drone::unloadAndValidate()
	pre droneNotEmpty : self.capacity <> 0
	pre droneIsAtBox : Box.allInstances-> one(b | b.distance(self) =0) and not Warehouse.allInstances-> exists (w | w.distance(self) =0)
	post droneIsEmpty : self.capacity = 0
	post droneIsStillAtBox : Box.allInstances-> one(b | b.distance(self) =0) and not Warehouse.allInstances-> exists (w | w.distance(self) =0)

context Drone::move(moveX:Integer, moveY:Integer)
	pre nothingAtDestination : not Drone.allInstances -> exists(d2 | d2.position4drone.x = self.position4drone.x + moveX and d2.position4drone.y = self.position4drone.y + moveY)
	pre droneEnergyIsGreaterThan1 : self.energy > 0
	pre exactlyOneUnitLenghtMove : moveX + moveY = 1
	post droneChangedLocation : ((self.position4drone.x <> self.position4drone.x@pre) and (self.position4drone.y = self.position4drone.y@pre)) or ((self.position4drone.x = self.position4drone.x@pre) and (self.position4drone.y <> self.position4drone.y@pre))


--___________________________
--ASSOCIATIONS
--___________________________ 

association command between
	Command [1] role cmd4product
	Product [*] role product4cmd
end

association delivery between
	Command [1] role cmd4drone
	Drone [1] role drone4cmd
end

association destination between
	Command [0..1] role cmd4Box
	Box [1] role cmdDestination
end

association positionD between
	Drone [0..1] role drone4position
	Point [1] role position4drone
end
