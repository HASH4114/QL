model Delivery


enum Etat_Box {Free, Occupied, Full}
--_________________________
--CLASSES
--_________________________

class Point
	attributes 
		x : Integer
		y : Integer	
	operations
		-- Computing the distance between two points 
		d(p2 : Point ) : Integer =
			(self.x - p2.x).abs + (self.y - p2.y).abs
		-- Déterminer si à un point, il y a une Box ou une Warehouse
		-- voir droneOnMyself. ^^
end

class Box < Point
    attributes
        capacity : Integer
        state : Etat_Box init = Etat_Box::Free
    operations 
        voisins() : Set(Box) =
            Box.allInstances() -> select (n | d(n) < 3)
        voisinsPlus() : Set(Box) =
            self.voisins() -> closure (b|b.voisins())
        distance(d : Drone) : Integer =
            (self.x-d.position4drone.x).abs + (self.y-d.position4drone.y).abs
    	setOccupied()
    	begin
    		self.state := Etat_Box::Occupied;
		end

	statemachines
    psm StateMachineForBox
        states
        	startUp:initial
            free
            full
            occupied
         transitions
         	startUp -> free { create }
            free -> occupied {[Drone.allInstances()->exists(d | distance(d) = 0)] setOccupied()}
    end
end

class Drone
attributes 
	energy : Integer init = 0
	capacity : Integer
operations
	
	assign(c : Command)
	begin
		insert(c, self) into delivery;
	end

	//TODO : poids total du drone += poids des produits
	fill(weight : Integer)
	begin
		self.capacity := weight;
	end

	recharge ()
	begin
		-- time ++
		self.energy := self.energy +1;
	end

statemachines
	psm StateMachineOfADrone
		states
			startUp:initial
			commandAssigned
			productsCharged
		transitions
			startUp -> commandAssigned {assign()}
			commandAssigned -> productsCharged {fill()}
	end
end

class Command
operations
 	f1()
	begin

	end
statemachines
	psm StateMachineForACommand
		states
			Waiting:initial
			Assigned
			Finished
		transitions
			Waiting -> Assigned { f1() }
			Assigned -> Finished { f1() }
	end
end
class Warehouse < Box end
class Product end 
class Map end
class Time end


--_______________________________
--CONTRAINTES
--_______________________________

constraints

--_____________
--Sur les classes
--_____________

context Warehouse inv oneWarehouse : Warehouse.allInstances->size=1


context b1,b2:Box inv noTwoBoxesAtSamePlace : 
	 (b1.x = b2.x) and 
	 (b1.y = b2.y)
	 implies b1 = b2


context d1,d2:Drone inv noTwoDronesAtSamePlace :
	(d1.position4drone.x = d2.position4drone.x) and
	(d1.position4drone.y = d2.position4drone.y)
	implies d1 = d2


context w:Warehouse inv neighbourBoxNearWarehouse :
    Box.allInstances() -> exists (b | d(b) < 3 )

context Drone inv batteryPositive : self.energy >= 0
context Drone inv batteryNotTooHigh : self.energy <= 3 
context Drone inv maxDroneNb : Drone.allInstances -> size <= 15
-- DNB
context Box inv maxBoxNb : Box.allInstances -> size <=20
-- RNB
context Drone inv droneCapacityPositive : self.capacity >= 0
context Drone inv droneCapacityMax : self.capacity <= 20 
-- DCAP
context Box inv boxCapacityPositive : self.capacity >= 0
context Box inv boxCapacityMax : self.capacity <= 50
-- RCAP

context Point inv numberOfNeighbours : 
	(self.neighbour-> size >=2) and
	(self.neighbour-> size <=4)

-- Il faut que les voisins ne soient pas à plus de 1
context p:Point inv neighboursAreClose :
	p.neighbour->forAll(n | 
	(((n.x - p.x = 1) or
	(n.x - p.x =-1)) and
	n.y - p.y =0) or
	(((n.y - p.y = 1) or
	(n.y - p.y =-1)) and
	n.x - p.x =0))

-- Voisins doivent être différents !!! Pas besoin mais expliquer dans le dossier

context b1:Box inv transitiveClosureComplete :
	b1.voisinsPlus()->includesAll(Box.allInstances())
--_____________
--Sur les fonctions (post et pré condition)
--_____________
	
context Drone::recharge()
	pre rechargePre1: self.energy < 3
	pre rechargePre2: Box.allInstances->exists (b | b.distance(self) =0)
	post rechargePost1: Box.allInstances->exists (b | b.distance(self) =0)
	-- post rechargePost2 : tempsAprès = tempsAvant + nbRecharges

context Drone::fill(weight:Integer)
	pre beInTheWh: Warehouse.allInstances->exists(w | w.distance(self) =0)
	pre isEmpty: self.capacity = 0
	--On considère qu'une commande correspond à un seul aller-retour

--context Drone::assign(c:Command)	
	--On considère qu'une commande correspond à un seul aller-retour
	--pre productsOfCommand: self.cmd4drone.product4cmd.forAll()


--___________________________
--ASSOCIATIONS
--___________________________ 

association map between
	Map [1] role map4point
	Point [*] role point4map
end

association command between
	Command [1] role cmd4product
	Product [*] role product4cmd
end

association delivery between
	Command [1] role cmd4drone
	Drone [1] role drone4cmd
end

association destination between
	Command [1] role cmd4Box
	Box [1] role cmdDestination
end

association positionD between
	Drone [1] role drone4position
	Point [1] role position4drone
end

association displacement between
	Drone [1] role drone4displ
	Point [1] role destination
end

association droneWarehouse between
	Drone [*] role droneInWarehouse
	Warehouse [1] role warehouse4drones
end

association neighbour between
	Point [1] role pointConcerned
	Point [2..4] role neighbour
end